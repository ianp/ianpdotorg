<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Eclipse | Digital Magpie]]></title>
  <link href="http://ianp.org/categories/eclipse/atom.xml" rel="self"/>
  <link href="http://ianp.org/"/>
  <updated>2012-11-06T18:46:08+01:00</updated>
  <id>http://ianp.org/</id>
  <author>
    <name><![CDATA[Ian Phillips]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Christmas Gift: PMD 3.9]]></title>
    <link href="http://ianp.org/2006/12/20/christmas-gift-pmd-39"/>
    <updated>2006-12-20T14:19:10+01:00</updated>
    <id>http://ianp.org/2006/12/20/christmas-gift-pmd-39</id>
    <content type="html"><![CDATA[<p>Just in time for Christmas, <a href="http://tomcopeland.blogs.com/juniordeveloper">Tom Copeland</a> has <a href="http://tomcopeland.blogs.com/juniordeveloper/2006/12/pmd_39_three_ti.html">announced</a> a
new release of <a href="http://pmd.sourceforge.net/">PMD</a> with some notable speed increases. Hopefully
this will make it fast enough to use the <a href="http://pmd.sourceforge.net/integrations.html#eclipse">Eclipse plug-in</a> in
regular development, rather than having a separate ‘analysis’ phase to
clean up any warts before each release.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using JUnit in Eclipse Ant Builds]]></title>
    <link href="http://ianp.org/2004/11/18/using-junit-in-eclipse-ant-builds"/>
    <updated>2004-11-18T18:11:41+01:00</updated>
    <id>http://ianp.org/2004/11/18/using-junit-in-eclipse-ant-builds</id>
    <content type="html"><![CDATA[<p>Just a quick note so that it gets into the
<a href="http://www.google.com">Google</a> help engine. By default the copy of
<a href="http://ant.apache.org">Ant</a> that is included with
<a href="http://www.eclipse.org">Eclipse</a> does not reference it’s own internal
copy of <a href="http://www.junit.org">JUnit</a> on it’s class path, to change this
open up the preferences window (hit command-comma if you’re on a Mac)
and open the Ant/Runtime node then add the JUnit location to the global
path. If you’re doing full-source editing (which is highly recommended
for all Eclipse users!) then you can just add a workspace reference and
it will work fine.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Classpaths in Eclipse]]></title>
    <link href="http://ianp.org/2004/10/03/dynamic-classpaths-in-eclipse"/>
    <updated>2004-10-03T05:10:58+02:00</updated>
    <id>http://ianp.org/2004/10/03/dynamic-classpaths-in-eclipse</id>
    <content type="html"><![CDATA[<p>In Eclipse your plug-ins normally have their classpath’s based upon
their dependencies. I’m playing around with an RCP based application
that will need to reference external libraries to avoid onerous
licensing requirements. Here’s the somewhat convoluted code required to
do this:</p>

<p><code>java
Context getContext() {
    if (context != null) { return context; }
    final Properties props = new Properties();
    props.put(Context.INITIAL_CONTEXT_FACTORY, getInitialContextFactory());
    props.put(Context.PROVIDER_URL, getProviderURL());
    props.put(Context.SECURITY_PRINCIPAL, getDirectoryPrincipal());
    props.put(Context.SECURITY_CREDENTIALS, getDirectoryCredentials());
    URL[] classpath = null;
    Plugin plugin = JmsPlugin.getPlugin();
    try {
        String stringList = plugin.getPluginPreferences().getString(PreferencesInitializer.CLASS_PATH);
        StringTokenizer st = new StringTokenizer(stringList, File.pathSeparator);
        ArrayList v = new ArrayList();
        while (st.hasMoreElements()) {
            v.add(new URL("file://" + st.nextElement()));
        }
        classpath = (URL[]) v.toArray(new URL[v.size()]);
    } catch (MalformedURLException e) {
        String msg = e.getMessage();
        Debug.error(plugin, 0, msg != null ? msg : "", e);
        throw new RuntimeException(e);
    }
    ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
    ClassLoader newClassLoader = new URLClassLoader(classpath, getClass().getClassLoader());
    try {
        Thread.currentThread().setContextClassLoader(newClassLoader);
        context = new InitialDirContext(props);
    } catch (NamingException e) {
        String msg = e.getMessage();
        Debug.error(plugin, 0, msg != null ? msg : "", e);
        throw new RuntimeException(e);
    } finally {
        Thread.currentThread().setContextClassLoader(oldClassLoader);
    }
    return context;
}
</code></p>

<p>The relevant code is in the first <code>try... catch</code> block. Then I can
have this plug-in rely on a second plug in which includes the JMS
interfaces only, and have a preference page which allows the user to
select a third party JMS provider by URL. At the moment it won’t handle
JMS providers that reply on native methods, but that could be fixed the
same way if needed. The <code>Debug.error(...)</code> is just a utility class to
log an Eclipse <code>IStatus.ERROR</code> message. As an added benefit of this
approach, because I use the latest API version in my JMS plugin, I can
check for a JMS version at runtime using the metadata returned by
<code>Connection.getMetaData()</code> and then only call JMS 1.1 supplied methods
when they are available.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Interactive Programming]]></title>
    <link href="http://ianp.org/2004/09/24/interactive-programming"/>
    <updated>2004-09-24T07:09:45+02:00</updated>
    <id>http://ianp.org/2004/09/24/interactive-programming</id>
    <content type="html"><![CDATA[<p>After playing around with Lisp for a few days I’ve diverted myself back
to a small Java project. Almost immediately I’m missing the Lisp
environment! To be sure there are some things that I prefer about my
Java environment, which is <a href="http://www.eclipse.org">Eclipse</a>, but I just
miss having an interactive top-level so much! It’s just amazingly
convenient to be able to try sunning a fragment of code, and the ability
to tweak it and try again if you hit any problems is such a productvity
boost.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SWT Look & Feel]]></title>
    <link href="http://ianp.org/2004/04/11/swt-look-feel"/>
    <updated>2004-04-11T07:04:14+02:00</updated>
    <id>http://ianp.org/2004/04/11/swt-look-feel</id>
    <content type="html"><![CDATA[<p><img src="/images/2004/04/emulated-vs-native.png" title="New Eclipse Widgets" ></p>

<p>Recently in the <a href="news://news.eclipse.org/eclipse.platform">Eclipse news group</a>
there’s been a lot of complaints about the new widget style that is now
the default in mlilestone 8.</p>

<p>Many people are saying that the new widgets are bad because they are emulated in Java, and not real native widgets
at all. This seems really odd to me in some ways, since the widgets have
always been emulated in Java, it’s not like this is some new thing
that’s been sprung upon us by the developers. But then in other ways I’m
not surprised, because for all Eclipse’s touted native look and feel
it’s always really been a Windows application.</p>

<p>Compare the new Eclipse widgets with those of a native Gnome application (GEdit in this case)
and you’ll see at once that they look out of place. But this has always
been the case. The real solution surely, is to use genuine native
widgets here. The only reason the Windows crowd are screaming now is
that Eclipse is becoming more cross platform in it’s look and feel, not
less.</p>
]]></content>
  </entry>
  
</feed>
