<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: XML | Digital Magpie]]></title>
  <link href="http://ianp.org/categories/xml/atom.xml" rel="self"/>
  <link href="http://ianp.org/"/>
  <updated>2013-01-01T21:00:26+01:00</updated>
  <id>http://ianp.org/</id>
  <author>
    <name><![CDATA[Ian Phillips]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Level Definition DTD for PushButtonEngine]]></title>
    <link href="http://ianp.org/2009/05/23/level-definition-dtd-for-pushbuttonengine"/>
    <updated>2009-05-23T04:19:42+02:00</updated>
    <id>http://ianp.org/2009/05/23/level-definition-dtd-for-pushbuttonengine</id>
    <content type="html"><![CDATA[<p>I use Oxygen for all my XML editing and if you have a DTD or schema it has some pretty neat autocompletion and error highlighting features, with that in mind I’ve created a basic DTD for the level definition file in <a href="http://pushbuttonengine.com/">PBE</a>, you can grab it from <a href="/code/2009/05/pbelevel.dtd">here</a>. Note that it’s not ideal, as you get spurious warnings for the fields that you specify inside your component definitions, but there’s not much that can be done about that.</p>

<p><strong>Update:</strong> added an XSD <a href="/code/2009/05/pbelevel.xsd">version of the file</a>, this handles unparsed content gracefully, useful for components.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Adding Namespace Support to RvSnoop]]></title>
    <link href="http://ianp.org/2006/10/17/adding-namespace-support-to-rvsnoop"/>
    <updated>2006-10-17T09:58:15+02:00</updated>
    <id>http://ianp.org/2006/10/17/adding-namespace-support-to-rvsnoop</id>
    <content type="html"><![CDATA[<p>For <a href="http://rvsnoop.prg/">RvSnoop</a> I’m currently working on adding namespaces to all of
the files that are used to save the application preferences and also the
project files. This is a Good Thing in and of itself, as it allows me to
use <a href="http://www.w3.org/XML/Schema">XML Schema</a> to validate and document the files formats. But,
more importantly, it gives me the opportunity to refactor as I go alond,
the general plan is to make the projects in the next release be based on
directories rather than a single XML file, this will allow me to use a
disk based storage mechanism for messages so that they will be
persistent across sessions.</p>

<h3 id="playing-well-with-others">Playing Well With Others</h3>

<p>At the same
time, I’ve taken the opportunity to include some of the <a href="http://www.apache.org/">Apache</a>
<a href="http://jakarta.apache.org/commons/index.html">Commons</a> libraries in the build. There were (well, still are) a
number of small utility classes scattered around which I’m planning on
replacing with the versions from Apache. One side effect of this is that
the build is increasing in size, to help control this I’m going to
remove the <a href="http://www.oracle.com/database/berkeley-db/je/index.html">Berkeley DB</a> dependency from the build. I was
origiannly planning to use this for the on disk message store but I’ve
changed my mind here. My current thinking is to just write the messages
out to files but to have a set of indexes (probably built using
<a href="http://lucene.apache.org/java/docs/index.html">Lucene</a>) as well for searching and sorting. There should be
another (alpha) release out later this week with the Commons and
Berkeley DB changes complete, and a release next week with the new
project structure.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Configuration via XML or code?]]></title>
    <link href="http://ianp.org/2006/05/02/configuration-via-xml-or-code"/>
    <updated>2006-05-02T19:34:56+02:00</updated>
    <id>http://ianp.org/2006/05/02/configuration-via-xml-or-code</id>
    <content type="html"><![CDATA[<p>When is using XML based configuration files preferable to using source
based interfaces and/or classes? I’ve been taking a look at command
frameworks such as those that come with the various rich client toolkits
out there, and also <a href="http://pietschy.org/software/gui-commands/">GUI Commands</a>. It struck me that
many things which I would allow via a concrete class or an abstract base
class these frameworks try to push out into XML files. I can see that
XML could be good for huge apps such as, for example,
<a href="http://www.eclipse.org/">Eclipse</a>, where the developers want to provide
extensibility without a huge class loading overhead.</p>

<p>But most of these
rich client kits are designed to be used to create small to medium sized
applications and if this is what you are doing then I don’t see the
point of scattering configuration information around the place, it’s
better to keep it all together and the only place that this can happen
is right there in the source code.</p>

<p>One final argument for keeping some
of this external is for easy internationalisation, but this can be
achieved simply using standard Java resource bundles or Eclipse style
NLS libraries (I prefer the eclipse style NLS approach as it makes code
more readable).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Where is the user interface?]]></title>
    <link href="http://ianp.org/2005/11/17/where-is-the-user-interface"/>
    <updated>2005-11-17T15:56:55+01:00</updated>
    <id>http://ianp.org/2005/11/17/where-is-the-user-interface</id>
    <content type="html"><![CDATA[<p>This is related to this quote by Michael Kay on the XML-DEV mailing
list, on the subject of validation.</p>

<blockquote>
  <p>There is also scope for reasonableness checks to catch data input
errors. But they belong as close to the user interface level as
possible, not at the information management level.</p>
</blockquote>

<p>Which is fine as far as it goes but the use of the term ‘user interface’ is misleading, I think, to most people (myself included) this implies ‘end user’ but this is not always the case. If, for example, you are writing a service (web- or otherwise) for external, or even only internal, use, then the ‘user interface’ is the service interface that you expose and it’s perfectly reasonable (in fact, I’d argue that it’s pretty much essential) to validate every message that your service receives.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSR-173 Reference Implementation]]></title>
    <link href="http://ianp.org/2003/11/18/jsr-173-reference-implementation"/>
    <updated>2003-11-18T19:11:04+01:00</updated>
    <id>http://ianp.org/2003/11/18/jsr-173-reference-implementation</id>
    <content type="html"><![CDATA[<p>I’ve been looking at the new streaming API for XML (<a href="http;//www.jcp.org/en/jsr/detail?id=173">JSR-173</a>), I’ve been generally impressed but have found a bug in the reference implementation, here’s the details, using this test program:</p>

<p><code>java
import java.io.*;
import javax.xml.stream.*;
public class StaxWriterTest {
    static String nsURI = "http://ianp.org/nsURI";
    static String nsPrefix = "a";
    static int depth = 0; // Used to pretty print the output.
    static XMLStreamWriter w;
    public static void main(String[] args) {
        try {
            w.writeStartDocument();
            indent(1);
            w.writeStartElement(nsURI, "root");
            w.writeNamespace(nsPrefix, nsURI);
            indent(0);
            w.writeEmptyElement(nsURI, "levelOne");
            w.writeAttribute(nsURI, "foo", "foo");
            indent(0);
            w.writeStartElement(nsURI, "levelOne");
            w.writeEndElement();
            indent(1);
            w.writeStartElement(nsURI, "levelOne");
            indent(1);
            w.writeEmptyElement(nsURI, "levelTwo");
            w.writeAttribute(nsURI, "foo", "foo");
            indent(-2);
            w.writeEndElement();
            indent(0);
            w.writeStartElement(nsURI, "levelOne");
            w.writeEndElement();
            indent(-1);
            w.writeEndElement();
            w.flush();
            w.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }
    static void indent(int d) {
        try {
            if (d &lt; 0) { depth += d; }
            for (int i = 0; i &lt; depth; ++i)
            w.writeCharacters("  ");
            if (d &gt; 0) { depth += d; }
        } catch (XMLStreamException e) {
            throw new RuntimeException(e);
        }
    }
}
</code></p>

<p>This is using version 7 of the reference implementation, by the way. The program should produce this output:</p>

<p><code>xml
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;a:root xmlns:a="http://ianp.org/nsURI"&gt;
    &lt;a:levelOne a:foo="foo"/&gt;
    &lt;a:levelOne/&gt;&lt;/a:levelOne&gt;
    &lt;a:levelOne&gt;
        &lt;a:levelTwo a:foo="foo"/&gt;
    &lt;/a:levelOne&gt;
    &lt;a:levelOne/&gt;&lt;/a:levelOne&gt;
&lt;/a:root&gt;
</code></p>

<p>But actually produces this:</p>

<p><code>xml
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;a:root xmlns:a="http://ianp.org/nsURI"&gt;
    &lt;a:levelOne a:foo="foo"/&gt;
    &lt;a:levelOne/&gt;&lt;/a:levelOne&gt;
    &lt;a:levelOne/&gt;
        &lt;a:levelTwo a:foo="foo"/&gt;
    &lt;/a:levelOne&gt;
    &lt;a:levelOne/&gt;&lt;/a:levelOne&gt;
&lt;/a:root&gt;
</code></p>

<p>Line 5 is generated as an empty element instead of a start element. I’ve pointed this out the to JCP committee, we’ll see if they repsond.</p>

]]></content>
  </entry>
  
</feed>
